/******************************************************************************
 * An automatically-generated self-referential program generated by kleene.
 * This source file contains a function called kleene::MySource() that produces
 * a C++ std::string containing the program's source code, which can be used
 * in the remainder of the program.
 *
 * This program works using a modified version of the construction detailed in
 * "Introduction to the Theory of Computation, Second Edition" by Michael
 * Sipser in his proof of a special case of Kleene's Second Recursion Theorem.
 * In particular, the program works as follows.  We assume that we have the
 * ability to write a function that, given a program's source, produces a new
 * program that prints out that program's source code.  We then produce a
 * program that given the source code of *some* program, combines the
 * representation of that program along with a representation of a program that
 * produces that program.  If we then run this program on its own source, it
 *
 * 1. Produces a representation of its own source code.
 * 2. Produces a program that produces a representation of its source code,
 *    then combines it with a description of a program that prints a
 *    representation of that source code.
 *
 * In the case of C++, the "representation" of a program is a pair of vectors
 * of strings, where the concatenation of these vectors represents a program
 * that takes care of step (2) and has a "hole" where the code for (1) should
 * go.  The program then concatenates together all of the logic for the first
 * half, then fills in the "hole" by producing a program that prints out a
 * representation of a program that prints the source gathered together, and
 * finally prints out the second half of the program.  The user code can then
 * call this function to access the representation.
 */

#include <iostream>
#include <utility>
#include <string>
#include <vector>
#include <sstream>

namespace kleene {
  /* Private implementation detail namespace; should not be necessary to look
   * at or modify this code.
   */
  namespace detail {
    /* A utility function that prints out the contents of a string, escaping 
     * all quotes and slashes it finds.
     */
    void OutputEscaped(::std::ostream& out, const ::std::string& line) {
      out << '"';
      for (unsigned i = 0; i < line.length(); ++i) {
        if (line[i] == '\"')
          out << "\\\"";
        else if (line[i] == '\'')
          out << "\\\'";
        else if (line[i] == '\\')
          out << "\\\\";
        else if (line[i] == '\t')
          out << "\\t";
        else
          out << line[i];
      }
      out << '"';
    }
  
    /* This code is automatically generated to place a representation of the
     * program's source into a pair of vectors, as described above.
     */
    ::std::pair< ::std::vector< ::std::string>, ::std::vector< ::std::string> > PrintThisProgram() {
      ::std::pair< ::std::vector< ::std::string>, ::std::vector< ::std::string> > result;
      /* ----- START Escaped copy of the program's source code. ----- */
      result.first.push_back("/******************************************************************************");
      result.first.push_back(" * An automatically-generated self-referential program generated by kleene.");
      result.first.push_back(" * This source file contains a function called kleene::MySource() that produces");
      result.first.push_back(" * a C++ std::string containing the program\'s source code, which can be used");
      result.first.push_back(" * in the remainder of the program.");
      result.first.push_back(" *");
      result.first.push_back(" * This program works using a modified version of the construction detailed in");
      result.first.push_back(" * \"Introduction to the Theory of Computation, Second Edition\" by Michael");
      result.first.push_back(" * Sipser in his proof of a special case of Kleene\'s Second Recursion Theorem.");
      result.first.push_back(" * In particular, the program works as follows.  We assume that we have the");
      result.first.push_back(" * ability to write a function that, given a program\'s source, produces a new");
      result.first.push_back(" * program that prints out that program\'s source code.  We then produce a");
      result.first.push_back(" * program that given the source code of *some* program, combines the");
      result.first.push_back(" * representation of that program along with a representation of a program that");
      result.first.push_back(" * produces that program.  If we then run this program on its own source, it");
      result.first.push_back(" *");
      result.first.push_back(" * 1. Produces a representation of its own source code.");
      result.first.push_back(" * 2. Produces a program that produces a representation of its source code,");
      result.first.push_back(" *    then combines it with a description of a program that prints a");
      result.first.push_back(" *    representation of that source code.");
      result.first.push_back(" *");
      result.first.push_back(" * In the case of C++, the \"representation\" of a program is a pair of vectors");
      result.first.push_back(" * of strings, where the concatenation of these vectors represents a program");
      result.first.push_back(" * that takes care of step (2) and has a \"hole\" where the code for (1) should");
      result.first.push_back(" * go.  The program then concatenates together all of the logic for the first");
      result.first.push_back(" * half, then fills in the \"hole\" by producing a program that prints out a");
      result.first.push_back(" * representation of a program that prints the source gathered together, and");
      result.first.push_back(" * finally prints out the second half of the program.  The user code can then");
      result.first.push_back(" * call this function to access the representation.");
      result.first.push_back(" */");
      result.first.push_back("");
      result.first.push_back("#include <iostream>");
      result.first.push_back("#include <utility>");
      result.first.push_back("#include <string>");
      result.first.push_back("#include <vector>");
      result.first.push_back("#include <sstream>");
      result.first.push_back("");
      result.first.push_back("namespace kleene {");
      result.first.push_back("  /* Private implementation detail namespace; should not be necessary to look");
      result.first.push_back("   * at or modify this code.");
      result.first.push_back("   */");
      result.first.push_back("  namespace detail {");
      result.first.push_back("    /* A utility function that prints out the contents of a string, escaping ");
      result.first.push_back("     * all quotes and slashes it finds.");
      result.first.push_back("     */");
      result.first.push_back("    void OutputEscaped(::std::ostream& out, const ::std::string& line) {");
      result.first.push_back("      out << \'\"\';");
      result.first.push_back("      for (unsigned i = 0; i < line.length(); ++i) {");
      result.first.push_back("        if (line[i] == \'\\\"\')");
      result.first.push_back("          out << \"\\\\\\\"\";");
      result.first.push_back("        else if (line[i] == \'\\\'\')");
      result.first.push_back("          out << \"\\\\\\\'\";");
      result.first.push_back("        else if (line[i] == \'\\\\\')");
      result.first.push_back("          out << \"\\\\\\\\\";");
      result.first.push_back("        else if (line[i] == \'\\t\')");
      result.first.push_back("          out << \"\\\\t\";");
      result.first.push_back("        else");
      result.first.push_back("          out << line[i];");
      result.first.push_back("      }");
      result.first.push_back("      out << \'\"\';");
      result.first.push_back("    }");
      result.first.push_back("  ");
      result.first.push_back("    /* This code is automatically generated to place a representation of the");
      result.first.push_back("     * program\'s source into a pair of vectors, as described above.");
      result.first.push_back("     */");
      result.first.push_back("    ::std::pair< ::std::vector< ::std::string>, ::std::vector< ::std::string> > PrintThisProgram() {");
      result.first.push_back("      ::std::pair< ::std::vector< ::std::string>, ::std::vector< ::std::string> > result;");
      result.first.push_back("      /* ----- START Escaped copy of the program\'s source code. ----- */");
      result.second.push_back("      /* -----  END  Escaped copy of the program\'s source code. ----- */");
      result.second.push_back("      return result;");
      result.second.push_back("    }");
      result.second.push_back("  }");
      result.second.push_back("");
      result.second.push_back("  /* Function that actually generates the program\'s source code. */");
      result.second.push_back("  ::std::string MySource() {");
      result.second.push_back("    ::std::stringstream result;");
      result.second.push_back("    ");
      result.second.push_back("    /* Get a description of some program. */");
      result.second.push_back("    ::std::pair< ::std::vector< ::std::string>, ::std::vector< ::std::string> > myDescription = ");
      result.second.push_back("        ::kleene::detail::PrintThisProgram();");
      result.second.push_back("    ");
      result.second.push_back("    /* Print out the preamble by itself. */");
      result.second.push_back("    for (unsigned i = 0; i < myDescription.first.size(); ++i)");
      result.second.push_back("      result << myDescription.first[i] << ::std::endl;");
      result.second.push_back("    ");
      result.second.push_back("    /* Print out the description of a function that would generate all of ");
      result.second.push_back("     * this code.");
      result.second.push_back("     */");
      result.second.push_back("    for (unsigned i = 0; i < myDescription.first.size(); ++i) {");
      result.second.push_back("      result << \"      result.first.push_back(\";");
      result.second.push_back("      ::kleene::detail::OutputEscaped(result, myDescription.first[i]);");
      result.second.push_back("      result << \");\" << ::std::endl;");
      result.second.push_back("    }");
      result.second.push_back("    for (unsigned i = 0; i < myDescription.second.size(); ++i) {");
      result.second.push_back("      result << \"      result.second.push_back(\";");
      result.second.push_back("      ::kleene::detail::OutputEscaped(result, myDescription.second[i]);");
      result.second.push_back("      result << \");\" << ::std::endl;");
      result.second.push_back("    }");
      result.second.push_back("    ");
      result.second.push_back("    /* Print out the postamble by itself. */");
      result.second.push_back("    for (unsigned i = 0; i < myDescription.second.size(); ++i)");
      result.second.push_back("      result << myDescription.second[i] << ::std::endl;");
      result.second.push_back("    ");
      result.second.push_back("    return result.str();");
      result.second.push_back("  }");
      result.second.push_back("}");
      result.second.push_back("");
      result.second.push_back("/***** BEGIN User program *****/");
      result.second.push_back("#include <map>");
      result.second.push_back("#include <vector>");
      result.second.push_back("#include <list>");
      result.second.push_back("#include <map>");
      result.second.push_back("#include <set>");
      result.second.push_back("#include <deque>");
      result.second.push_back("#include <stack>");
      result.second.push_back("#include <bitset>");
      result.second.push_back("#include <algorithm>");
      result.second.push_back("#include <functional>");
      result.second.push_back("#include <numeric>");
      result.second.push_back("#include <utility>");
      result.second.push_back("#include <sstream>");
      result.second.push_back("#include <iostream>");
      result.second.push_back("#include <iomanip>");
      result.second.push_back("#include <cstdio>");
      result.second.push_back("#include <cmath>");
      result.second.push_back("#include <cstdlib>");
      result.second.push_back("#include <ctime>");
      result.second.push_back("#include <iterator>");
      result.second.push_back("#include <queue>");
      result.second.push_back("#include <cassert>");
      result.second.push_back("#include <cstring>");
      result.second.push_back("");
      result.second.push_back("using namespace std;");
      result.second.push_back("using namespace __gnu_cxx;");
      result.second.push_back("");
      result.second.push_back("#define fr(i,n) for(int i = 0; i < (int)(n);i++)");
      result.second.push_back("#define pl cout<<endl;");
      result.second.push_back("#define all(v) v.begin(),v.end()");
      result.second.push_back("#define alln(v,n) v.begin()+1,v.begin()+n");
      result.second.push_back("#define sz(v) v.size()");
      result.second.push_back("#define INF 1000001");
      result.second.push_back("#define pb push_back");
      result.second.push_back("#define PI 3.141592653589793");
      result.second.push_back("");
      result.second.push_back("");
      result.second.push_back("typedef unsigned int uint;");
      result.second.push_back("typedef long long int lli;");
      result.second.push_back("typedef vector<string, string> vpss;");
      result.second.push_back("typedef vector<int> vi;");
      result.second.push_back("typedef vector<vector<int> > vvi;");
      result.second.push_back("typedef vector<string> vs;");
      result.second.push_back("typedef vector<bool> vb;");
      result.second.push_back("typedef vector<char> vc;");
      result.second.push_back("typedef map<string, int> msi;");
      result.second.push_back("typedef vector<pair<int, int> > vpii;");
      result.second.push_back("typedef pair<int, int> pii;");
      result.second.push_back("");
      result.second.push_back("inline void unsetbit(unsigned int &n, int k) {n=n&(~(1<<k));}");
      result.second.push_back("inline void setbit(unsigned int &n, int k) {n=n|(1<<k);}");
      result.second.push_back("inline void toggle(unsigned int &n, int k) {n=n^(1<<k);}");
      result.second.push_back("inline uint gcd(uint a, uint b) {return !b?a:gcd(b,a%b);}");
      result.second.push_back("struct eqstr{bool operator()(const char* s1, const char* s2) const{return !strcmp(s1, s2);}};");
      result.second.push_back("");
      result.second.push_back("int main()");
      result.second.push_back("{");
      result.second.push_back("  cout << \"Hello world!\\n\";");
      result.second.push_back("  return 0;");
      result.second.push_back("}");
      result.second.push_back("");
      result.second.push_back("/*****  END  User program *****/");
      /* -----  END  Escaped copy of the program's source code. ----- */
      return result;
    }
  }

  /* Function that actually generates the program's source code. */
  ::std::string MySource() {
    ::std::stringstream result;
    
    /* Get a description of some program. */
    ::std::pair< ::std::vector< ::std::string>, ::std::vector< ::std::string> > myDescription = 
        ::kleene::detail::PrintThisProgram();
    
    /* Print out the preamble by itself. */
    for (unsigned i = 0; i < myDescription.first.size(); ++i)
      result << myDescription.first[i] << ::std::endl;
    
    /* Print out the description of a function that would generate all of 
     * this code.
     */
    for (unsigned i = 0; i < myDescription.first.size(); ++i) {
      result << "      result.first.push_back(";
      ::kleene::detail::OutputEscaped(result, myDescription.first[i]);
      result << ");" << ::std::endl;
    }
    for (unsigned i = 0; i < myDescription.second.size(); ++i) {
      result << "      result.second.push_back(";
      ::kleene::detail::OutputEscaped(result, myDescription.second[i]);
      result << ");" << ::std::endl;
    }
    
    /* Print out the postamble by itself. */
    for (unsigned i = 0; i < myDescription.second.size(); ++i)
      result << myDescription.second[i] << ::std::endl;
    
    return result.str();
  }
}

/***** BEGIN User program *****/
#include <map>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iterator>
#include <queue>
#include <cassert>
#include <cstring>

using namespace std;
using namespace __gnu_cxx;

#define fr(i,n) for(int i = 0; i < (int)(n);i++)
#define pl cout<<endl;
#define all(v) v.begin(),v.end()
#define alln(v,n) v.begin()+1,v.begin()+n
#define sz(v) v.size()
#define INF 1000001
#define pb push_back
#define PI 3.141592653589793


typedef unsigned int uint;
typedef long long int lli;
typedef vector<string, string> vpss;
typedef vector<int> vi;
typedef vector<vector<int> > vvi;
typedef vector<string> vs;
typedef vector<bool> vb;
typedef vector<char> vc;
typedef map<string, int> msi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;

inline void unsetbit(unsigned int &n, int k) {n=n&(~(1<<k));}
inline void setbit(unsigned int &n, int k) {n=n|(1<<k);}
inline void toggle(unsigned int &n, int k) {n=n^(1<<k);}
inline uint gcd(uint a, uint b) {return !b?a:gcd(b,a%b);}
struct eqstr{bool operator()(const char* s1, const char* s2) const{return !strcmp(s1, s2);}};

int main()
{
  cout << "Hello world!\n";
  return 0;
}

/*****  END  User program *****/

